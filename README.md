# CI-CD

**Continuous Integration (CI)** - _непрерывная интеграция_ - практика непрерывной интеграции заключается в 
том, что во время разработки код приложения, хранится в репозитории системы управления версиями, например _Git_'е. 
Разработчики непрерывно вносят изменения в код. 
Система непрерывной интеграции **собирает** приложение для каждого изменния кода (_push_'a, _PR_, _MR_, _Tag_ и т.п. в git репозиторий),
выполняет **тесты**, дополнительные **проверки** (_lint_, _security_, и т.п.) и др. наборы скриптов.
_Эти шаги гарантируют, что изменения проходят все тесты, 
рекомендации и стандарты соответствия кода, которые установлены для приложения._

**Continuous Delivery (CD)** - _непрерывная доставка_:

Теперь, в жизненном цикле приложения, кроме того, что приложение создается и тестируется каждый раз, 
когда изменение кода вносится в кодовую базу на этапе _ci_, приложение также непрерывно развертывается _cd_.  
Однако при **непрерывной доставке развертывание инициируется вручную**.

_Непрерывная доставка проверяет код автоматически, но требует вмешательства человека, 
чтобы вручную инициировать развертывание изменений._

**Continuous Deployment (CD)** - _Непрерывное развертывание_ :

Это еще один шаг после непрерывной интеграции, аналогичный непрерывной доставке.
Разница в том, что **запуск развертывания приложения происходит автоматически**.  
Вмешательство человека не требуется. Триггером может быть MR в мастер, tag и т.п.

CI/CD как правило строиться на взаимодействии системы управления версиями, системы автоматизации, репориториями для хранения артифактов полученных путем компилирования/сборки приложения (например исполняемые файлы, архивы, образы).

Система автоматизации может быть любой, все зависит от фантазии автора. Примером готовых, свободнораспространяемых, являются:

- Jenkins
- GitLab (это больше чем только система автоматизации)

Конечно есть и другие, мы ограничены скорее своей фантазией.

**Основные моменты CI**

Jenkins представляет собой среду автоматизации. В нашем "деле" он используется для запуска задач, которые описываются скриптами (так же называемых конвейр, pipeline, job). Перечислим основные этапы пайплана, которые наиболее часто используют:

- Сборка проекта (build), например сборка jar maven'ом, и сохранение его в репозитории (например, Nexus)
- Тестирование, 
- Проверка кода статистическим анализатором 
- Сборка контейнера, например docker image, и сохранение его в репозитории (например, Nexus или hub.docker.com)

Для выполнения этих и других задач в Jenkins подключаются плагины.

Для повышения производительности и эффективности, запуск pipline, выполняется не на основной машине, где установлена система автоматизации (Jenkins, GitLab и т.п.) а на других, обычно называемых агентами, или runner (в терминах GitLab).

Pipeline может быть сохранен в виде файла и храниться в коде проекта, например jenkinsfile (для Jenkins) или .gitlab-ci.yml (для GitLab).
Кроме того Jenkins мозволяет создать pipeline, который будет храниться автономно, на сервере Jenkins. Используя webhook и плагины запуск такого pipeline может быть организован при коммите, выставлении PR, и др. событиях в системах типа Bitbucket.

**Основные моменты CD**

Доставка приложения как правило включает в себя доставку на сервер файла инфраструктуры и запуск его выполнения. Если архитектура микрсервисная, то каждый микросервис разворачивается на своем шаге. Такой шаг можеб быит выполнен по определному условию. Например, запуск pipeline происходит человеком, и он выбирает какие микросервисы должны буть развернуты (первый запуск) или обновлены.

Для систем на без k8s отправляются файлы deployment, service, configMap. Отдельным этапом может быть установка параметров для секретов.
Для систем на базе docker может быть отправлен фаил docker-compose. 
В некоторых случаях можно настроить обновление микросервисов при обновлении образа в репозиториии, например используя [watchtower](https://github.com/containrrr/watchtower). Такой подход может быть удобен для девелоперской среды, но в промышленной среде так обновлять не надо.
